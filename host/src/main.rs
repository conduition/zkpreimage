// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{PROVABLE_SHA256_DLOG_ELF, PROVABLE_SHA256_DLOG_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Arbitrary input.
    let input = [1u8; 32];

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    println!("proving execution...");
    let receipt = prover
        .prove(env, PROVABLE_SHA256_DLOG_ELF)
        .expect("failed to prove"); // <-------- CRASH HERE

    // Parse the journal from a receipt.
    let output: Vec<u8> = receipt
        .journal
        .decode()
        .expect("failed to decode journal output");

    assert_eq!(output.len(), 32 + 33);

    let hash = &output[..32];
    let point = &output[32..];

    println!("receipt journal output:");
    println!("  hash:  {}", hex::encode(hash));
    println!("  point: {}", hex::encode(point));

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    println!("verifying receipt...");
    receipt.verify(PROVABLE_SHA256_DLOG_ID).unwrap();
    println!("OK");
}
